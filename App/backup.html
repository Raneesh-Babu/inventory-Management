<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Shop Data Management</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { font-family: Arial, sans-serif; background:#f5f7fb; margin:0; padding:20px; }
    .card { max-width:800px; margin:auto; background:#fff; padding:24px; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.1); }
    h2 { margin-top:0; }
    .shop-header { 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px; 
      border-radius: 8px; 
      margin-bottom: 25px; 
      color: white;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
    }
    .shop-header h3 { 
      margin: 0 0 10px 0; 
      font-size: 24px; 
      font-weight: 600;
    }
    .shop-header .shop-id { 
      opacity: 0.9; 
      font-size: 14px; 
      font-family: 'Courier New', monospace; 
      background: rgba(255,255,255,0.1);
      padding: 5px 10px;
      border-radius: 4px;
      display: inline-block;
    }
    .shop-details {
      margin-top: 15px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
    }
    .detail-item {
      background: rgba(255,255,255,0.1);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 13px;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 12px;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    .modal-title {
      margin-top: 0;
      margin-bottom: 20px;
      color: #333;
    }
    .form-group {
      margin-bottom: 20px;
    }
    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #555;
    }
    .form-group input,
    .form-group select {
      width: 100%;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      font-size: 16px;
      transition: border-color 0.3s;
    }
    .form-group input:focus,
    .form-group select:focus {
      border-color: #667eea;
      outline: none;
    }
    .modal-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 30px;
    }
    button { 
      padding:14px 22px; 
      border:none; 
      border-radius:8px; 
      cursor:pointer; 
      font-size:15px; 
      font-weight:500;
      margin: 5px;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none !important;
    }
    .danger { background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color:#fff; }
    .danger:hover { background:linear-gradient(135deg, #f5576c 0%, #f093fb 100%); }
    .primary { background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:#fff; }
    .primary:hover { background:linear-gradient(135deg, #764ba2 0%, #667eea 100%); }
    .success { background:linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color:#fff; }
    .success:hover { background:linear-gradient(135deg, #38ef7d 0%, #11998e 100%); }
    .warning { background:linear-gradient(135deg, #f6d365 0%, #fda085 100%); color:#333; }
    .warning:hover { background:linear-gradient(135deg, #fda085 0%, #f6d365 100%); }
    .secondary { background:#6c757d; color:#fff; }
    .secondary:hover { background:#5a6268; }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    input[type=file] { padding:8px; }
    .hidden { display:none; }
    .log { 
      margin-top:20px; 
      font-size:14px; 
      white-space:pre-line; 
      background: #f8f9fa; 
      padding: 20px; 
      border-radius: 8px; 
      border-left: 4px solid #6c757d;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
    }
    .log.error { border-left-color: #f5576c; background: #f8d7da; }
    .log.success { border-left-color: #38ef7d; background: #d4edda; }
    .log.warning { border-left-color: #fda085; background: #fff3cd; }
    .log.info { border-left-color: #667eea; background: #d1ecf1; }
    .progress-container {
      margin-top:20px;
      background:#f8f9fa;
      padding:20px;
      border-radius:8px;
      display:none;
    }
    .progress-bar {
      background:#e9ecef;
      border-radius:10px;
      overflow:hidden;
      height:18px;
      margin-bottom:10px;
    }
    .progress-fill {
      height:100%;
      width:0%;
      background:linear-gradient(90deg, #667eea, #764ba2);
      transition:width .3s ease;
      border-radius:10px;
      position:relative;
      overflow:hidden;
    }
    .progress-fill::after {
      content:'';
      position:absolute;
      top:0;
      left:0;
      bottom:0;
      right:0;
      background-image:linear-gradient(
        -45deg,
        rgba(255,255,255,0.2) 25%,
        transparent 25%,
        transparent 50%,
        rgba(255,255,255,0.2) 50%,
        rgba(255,255,255,0.2) 75%,
        transparent 75%,
        transparent
      );
      background-size:50px 50px;
      animation:move 2s linear infinite;
    }
    @keyframes move {
      0% { background-position:0 0; }
      100% { background-position:50px 50px; }
    }
    .progress-text {
      font-size:14px;
      display:flex;
      justify-content:space-between;
      font-weight:500;
    }
    .stats {
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(150px, 1fr));
      gap:15px;
      margin:20px 0;
    }
    .stat-card {
      background:#f8f9fa;
      padding:15px;
      border-radius:8px;
      text-align:center;
      border-left:4px solid #667eea;
    }
    .stat-value {
      font-size:24px;
      font-weight:bold;
      color:#667eea;
      margin:5px 0;
    }
    .stat-label {
      font-size:12px;
      color:#6c757d;
      text-transform:uppercase;
      letter-spacing:1px;
    }
    .action-buttons {
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));
      gap:15px;
      margin:25px 0;
    }
    .icon {
      font-size:18px;
    }
    .restore-options {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
    }
    .option-group {
      display: flex;
      gap: 20px;
      margin: 15px 0;
      flex-wrap: wrap;
    }
    .radio-option {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }
    .radio-option input[type="radio"] {
      width: auto;
    }
  </style>
</head>
<body>
<div class="card" id="page">
  <div class="shop-header" id="shopHeader">
    <h3 id="shopName">Loading shop information...</h3>
    <div class="shop-id">Current Shop ID: <span id="shopIDDisplay">...</span></div>
    <div class="shop-details" id="shopDetails"></div>
  </div>
  
  <div class="stats" id="statsContainer" style="display:none;">
    <!-- Stats will be populated dynamically -->
  </div>
  
  <h2>üìä Shop Data Management</h2>
  <p style="color: #666; line-height: 1.6;">
    <b style="color: #f5576c;">‚ö†Ô∏è Warning:</b> Operations below affect shop data. 
    Delete Shop is <span style="color:red; font-weight:bold;">PERMANENT</span> and cannot be undone.
  </p>
  
  <div class="action-buttons">
    <button class="primary" onclick="downloadAllData()" id="btnBackup">
      <span class="icon">üíæ</span>
      Download Backup
    </button>
    <button class="success" onclick="showRestoreModal()" id="btnRestore">
      <span class="icon">üîÑ</span>
      Restore Data
    </button>
    <button class="warning" onclick="showStats()" id="btnStats">
      <span class="icon">üìà</span>
      Show Statistics
    </button>
    <button class="danger" onclick="deleteShop()" id="btnDelete">
      <span class="icon">üóëÔ∏è</span>
      Delete Shop
    </button>
  </div>
  
  <!-- Hidden file input for restore -->
  <input type="file" id="restoreFile" accept=".json" class="hidden" />
  
  <!-- Restore Modal -->
  <div class="modal" id="restoreModal">
    <div class="modal-content">
      <h3 class="modal-title">üîÑ Restore Data</h3>
      
      <div class="form-group">
        <label for="restoreShopID">Target Shop ID for Restore:</label>
        <input type="text" id="restoreShopID" placeholder="Enter Shop ID where data should be restored">
        <small style="color: #666; margin-top: 5px; display: block;">
          This is where the backup data will be restored to.
        </small>
      </div>
      
      <div class="form-group">
        <label for="restoreMode">Restore Mode:</label>
        <select id="restoreMode">
          <option value="merge">Merge - Keep existing data and add new records</option>
          <option value="replace">Replace - Clear existing data and restore from backup</option>
          <option value="update">Update - Update existing records and add new ones</option>
        </select>
      </div>
      
      <div class="restore-options">
        <label style="font-weight: bold; display: block; margin-bottom: 10px;">üìã Select Tables to Restore:</label>
        <div class="option-group" id="tableOptions">
          <!-- Table checkboxes will be populated here -->
        </div>
        <div style="margin-top: 10px;">
          <button type="button" onclick="selectAllTables()" class="secondary" style="padding: 8px 16px; font-size: 14px;">Select All</button>
          <button type="button" onclick="deselectAllTables()" class="secondary" style="padding: 8px 16px; font-size: 14px;">Deselect All</button>
        </div>
      </div>
      
      <div class="modal-actions">
        <button type="button" onclick="hideRestoreModal()" class="secondary">Cancel</button>
        <button type="button" onclick="startRestoreProcess()" class="success">Choose Backup File</button>
      </div>
    </div>
  </div>
  
  <div class="progress-container" id="progressContainer">
    <div style="margin-bottom: 10px; font-weight: 500;">Operation Progress:</div>
    <div class="progress-bar">
      <div class="progress-fill" id="progressBar"></div>
    </div>
    <div class="progress-text">
      <span id="progressText">0%</span>
      <span id="progressCount">0 / 0</span>
    </div>
  </div>
  
  <div class="log" id="log">‚úÖ Ready. Select an action to begin.</div>
</div>

<script>
// ================= CONFIGURATION =================
const API_KEY = 'jXXkrUUqrQK3RlESaDPs2gq0Eu0SK4Sw'; // Your Baserow API Key
const BASE_URL = 'https://api.baserow.io/api/database/rows/table';
const TABLES = {
  users: 729979,
  inventory: 734795,
  products: 734793,
  customers: 736204,
  ledger: 736207,
  sale: 736209,
  supplier: 744412,
  transaction: 745465,
  shops: 999999 // Update this with your actual shops table ID
};

// ================= STATE MANAGEMENT =================
let shopInfo = null;
let shopStats = {};
let isOperationInProgress = false;
let restoreOptions = {
  targetShopID: '',
  restoreMode: 'merge',
  selectedTables: []
};

// ================= GET VALUES FROM LOCALSTORAGE =================
function getShopID() {
  // Try different possible keys
  const possibleKeys = ['ShopIDtag', 'ShopIDTag', 'ShopID', 'shopID', 'shopId'];
  
  for (const key of possibleKeys) {
    const value = localStorage.getItem(key);
    if (value) {
      console.log(`Found Shop ID in localStorage with key "${key}": ${value}`);
      return value;
    }
  }
  
  throw new Error('Shop ID not found in localStorage. Please log in again.');
}

function getMobile() {
  // Try different possible keys
  const possibleKeys = ['MobileTag', 'mobileTag', 'Mobile', 'mobile', 'phone', 'Phone'];
  
  for (const key of possibleKeys) {
    const value = localStorage.getItem(key);
    if (value) {
      console.log(`Found Mobile in localStorage with key "${key}": ${value}`);
      return value;
    }
  }
  
  throw new Error('Mobile number not found in localStorage. Please log in again.');
}

// ================= API CONFIGURATION =================
const headers = {
  'Authorization': `Token ${API_KEY}`,
  'Content-Type': 'application/json'
};

// ================= MODAL FUNCTIONS =================
function showRestoreModal() {
  if (isOperationInProgress) {
    alert('Please wait for the current operation to complete.');
    return;
  }
  
  // Populate table options
  populateTableOptions();
  
  // Set default target shop ID to current shop
  const currentShopID = getShopID();
  document.getElementById('restoreShopID').value = currentShopID;
  restoreOptions.targetShopID = currentShopID;
  
  // Show modal
  document.getElementById('restoreModal').style.display = 'flex';
}

function hideRestoreModal() {
  document.getElementById('restoreModal').style.display = 'none';
  // Reset options
  restoreOptions = {
    targetShopID: '',
    restoreMode: 'merge',
    selectedTables: []
  };
}

function populateTableOptions() {
  const container = document.getElementById('tableOptions');
  let html = '';
  
  Object.keys(TABLES).forEach(tableName => {
    if (tableName === 'shops') return; // Exclude shops table
    
    html += `
      <div class="radio-option">
        <input type="checkbox" id="table_${tableName}" name="tables" value="${tableName}" checked>
        <label for="table_${tableName}">${tableName.charAt(0).toUpperCase() + tableName.slice(1)}</label>
      </div>
    `;
  });
  
  container.innerHTML = html;
}

function selectAllTables() {
  const checkboxes = document.querySelectorAll('input[name="tables"]');
  checkboxes.forEach(cb => cb.checked = true);
}

function deselectAllTables() {
  const checkboxes = document.querySelectorAll('input[name="tables"]');
  checkboxes.forEach(cb => cb.checked = false);
}

function getSelectedTables() {
  const checkboxes = document.querySelectorAll('input[name="tables"]:checked');
  return Array.from(checkboxes).map(cb => cb.value);
}

// ================= RESTORE PROCESS =================
function startRestoreProcess() {
  const targetShopID = document.getElementById('restoreShopID').value.trim();
  const restoreMode = document.getElementById('restoreMode').value;
  const selectedTables = getSelectedTables();
  
  if (!targetShopID) {
    alert('Please enter a target Shop ID');
    return;
  }
  
  if (selectedTables.length === 0) {
    alert('Please select at least one table to restore');
    return;
  }
  
  // Save restore options
  restoreOptions = {
    targetShopID,
    restoreMode,
    selectedTables
  };
  
  // Show confirmation
  const confirmMessage = `You are about to restore data to Shop ID: ${targetShopID}
  
Mode: ${restoreMode}
Tables: ${selectedTables.join(', ')}

Are you sure you want to proceed?`;

  if (confirm(confirmMessage)) {
    hideRestoreModal();
    // Trigger file selection
    document.getElementById('restoreFile').click();
  }
}

// ================= UI HELPER FUNCTIONS =================
function updateButtonState(buttonId, isWorking) {
  const button = document.getElementById(buttonId);
  if (isWorking) {
    button.disabled = true;
    button.style.opacity = '0.7';
  } else {
    button.disabled = false;
    button.style.opacity = '1';
  }
}

function setAllButtonsState(isWorking) {
  const buttons = ['btnBackup', 'btnRestore', 'btnStats', 'btnDelete'];
  buttons.forEach(btnId => updateButtonState(btnId, isWorking));
  isOperationInProgress = isWorking;
}

function showProgress(show) {
  document.getElementById('progressContainer').style.display = show ? 'block' : 'none';
}

function setProgress(done, total, message = '') {
  const percent = total > 0 ? Math.round((done / total) * 100) : 0;
  document.getElementById('progressBar').style.width = percent + '%';
  document.getElementById('progressText').innerText = `${percent}%`;
  document.getElementById('progressCount').innerText = `${done} / ${total}`;
  
  if (message) {
    log(message, 'info');
  }
}

function log(message, type = 'info') {
  const logElement = document.getElementById('log');
  const timestamp = new Date().toLocaleTimeString();
  const prefix = {
    'info': '‚ÑπÔ∏è',
    'success': '‚úÖ',
    'warning': '‚ö†Ô∏è',
    'error': '‚ùå'
  }[type] || 'üìù';
  
  const logEntry = `${prefix} [${timestamp}] ${message}\n`;
  logElement.innerText += logEntry;
  logElement.className = `log ${type}`;
  logElement.scrollTop = logElement.scrollHeight;
}

function clearLog() {
  document.getElementById('log').innerText = '';
  document.getElementById('log').className = 'log';
}

// ================= API HELPER FUNCTIONS =================
async function fetchWithPagination(tableId, filters = {}) {
  let allResults = [];
  let page = 1;
  
  while (true) {
    try {
      let url = `${BASE_URL}/${tableId}/?user_field_names=true&page=${page}`;
      
      // Add filters
      if (filters.shopID) {
        url += `&filter__ShopID__equal=${filters.shopID}`;
      }
      
      if (filters.mobile) {
        url += `&filter__Username__equal=${filters.mobile}`;
      }
      
      const response = await fetch(url, { headers });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      allResults = allResults.concat(data.results || []);
      
      if (!data.next) break;
      page++;
      
    } catch (error) {
      log(`Error fetching data: ${error.message}`, 'error');
      throw error;
    }
  }
  
  return allResults;
}

async function deleteTableData(tableId, shopID) {
  try {
    const data = await fetchWithPagination(tableId, { shopID: shopID });
    
    for (const record of data) {
      await fetch(`${BASE_URL}/${tableId}/${record.id}/`, {
        method: 'DELETE',
        headers
      });
    }
    
    return data.length;
  } catch (error) {
    log(`Error deleting table data: ${error.message}`, 'error');
    throw error;
  }
}

// ================= SHOP INFORMATION =================
async function loadShopInfo() {
  try {
    // Get values from localStorage
    const shopID = getShopID();
    const mobile = getMobile();
    
    log(`Loading shop info for Shop ID: ${shopID}, Mobile: ${mobile}`, 'info');
    
    // Fetch user info to check role
    const users = await fetchWithPagination(TABLES.users, { 
      shopID: shopID,
      mobile: mobile 
    });
    
    if (users.length === 0) {
      throw new Error('User not found in database');
    }
    
    const user = users[0];
    
    // Check if user is Manager
    if (user.Role !== 'Manager') {
      document.getElementById('page').innerHTML = `
        <div style="text-align: center; padding: 40px;">
          <h2 style="color: #f5576c;">‚õî Access Denied</h2>
          <p>Manager role required to access this page.</p>
          <p>Your role: <strong>${user.Role}</strong></p>
          <button onclick="window.history.back()" class="primary" style="margin-top: 20px;">
            ‚Üê Go Back
          </button>
        </div>
      `;
      return;
    }
    
    // Update UI with shop information
    updateShopUI(shopID, user);
    
    // Load initial statistics
    await loadShopStats();
    
  } catch (error) {
    log(`Failed to load shop information: ${error.message}`, 'error');
    document.getElementById('shopHeader').innerHTML = `
      <h3 style="color: #f5576c;">‚ùå Error Loading Shop</h3>
      <div class="shop-id" style="background: rgba(255,255,255,0.2);">
        Error: ${error.message}
      </div>
    `;
  }
}

function updateShopUI(shopID, user) {
  document.getElementById('shopName').textContent = `Shop ${shopID}`;
  document.getElementById('shopIDDisplay').textContent = shopID;
  
  const detailsHTML = `
    <div class="detail-item">
      <strong>üë§ Manager:</strong> ${user.Username || 'Unknown'}
    </div>
    <div class="detail-item">
      <strong>üì± Mobile:</strong> ${getMobile()}
    </div>
    <div class="detail-item">
      <strong>üéØ Role:</strong> ${user.Role}
    </div>
  `;
  
  document.getElementById('shopDetails').innerHTML = detailsHTML;
}

async function loadShopStats() {
  try {
    const shopID = getShopID();
    
    // Fetch counts from each table
    const statsPromises = Object.entries(TABLES).map(async ([tableName, tableId]) => {
      if (tableName === 'shops') return null;
      
      try {
        const data = await fetchWithPagination(tableId, { shopID: shopID });
        return { [tableName]: data.length };
      } catch (e) {
        return { [tableName]: 0 };
      }
    });
    
    const statsResults = await Promise.all(statsPromises);
    shopStats = Object.assign({}, ...statsResults.filter(Boolean));
    
    // Update stats display
    updateStatsUI();
    
  } catch (error) {
    log(`Could not load statistics: ${error.message}`, 'warning');
  }
}

function updateStatsUI() {
  const statsContainer = document.getElementById('statsContainer');
  if (Object.keys(shopStats).length === 0) return;
  
  const statsHTML = Object.entries(shopStats).map(([table, count]) => `
    <div class="stat-card">
      <div class="stat-value">${count}</div>
      <div class="stat-label">${table.charAt(0).toUpperCase() + table.slice(1)}</div>
    </div>
  `).join('');
  
  statsContainer.innerHTML = statsHTML;
  statsContainer.style.display = 'grid';
}

function showStats() {
  const statsContainer = document.getElementById('statsContainer');
  statsContainer.style.display = statsContainer.style.display === 'none' ? 'grid' : 'none';
  log(statsContainer.style.display === 'none' ? 'Statistics hidden' : 'Statistics displayed', 'info');
}

// ================= BACKUP FUNCTION =================
async function downloadAllData() {
  if (isOperationInProgress) {
    alert('Please wait for the current operation to complete.');
    return;
  }
  
  if (!confirm('üì• This will download all shop data as a JSON backup file. Continue?')) {
    return;
  }
  
  try {
    setAllButtonsState(true);
    clearLog();
    showProgress(true);
    log('Starting backup process...', 'info');
    
    const shopID = getShopID();
    const backup = {};
    let totalTables = Object.keys(TABLES).length;
    let completedTables = 0;
    
    // Fetch data from each table
    for (const [tableName, tableId] of Object.entries(TABLES)) {
      if (tableName === 'shops') continue;
      
      log(`Fetching ${tableName} data...`, 'info');
      try {
        const data = await fetchWithPagination(tableId, { shopID: shopID });
        backup[tableName] = data;
        log(`‚úì ${tableName}: ${data.length} records`, 'success');
      } catch (error) {
        log(`‚úó ${tableName}: Failed to fetch - ${error.message}`, 'error');
        backup[tableName] = [];
      }
      
      completedTables++;
      setProgress(completedTables, totalTables - 1); // Exclude shops table
    }
    
    // Add metadata
    backup.metadata = {
      shopId: shopID,
      mobile: getMobile(),
      backupDate: new Date().toISOString(),
      totalRecords: Object.values(backup).reduce((sum, data) => sum + (Array.isArray(data) ? data.length : 0), 0)
    };
    
    // Create and download the file
    const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `SHOP_${shopID}_BACKUP_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    log(`‚úÖ Backup completed successfully! Total records: ${backup.metadata.totalRecords}`, 'success');
    setProgress(totalTables - 1, totalTables - 1, 'Backup complete');
    
    // Refresh stats
    setTimeout(async () => {
      showProgress(false);
      await loadShopStats();
    }, 2000);
    
  } catch (error) {
    log(`Backup failed: ${error.message}`, 'error');
  } finally {
    setAllButtonsState(false);
  }
}

// ================= RESTORE FILE HANDLER =================
document.getElementById('restoreFile').onchange = async function(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  try {
    setAllButtonsState(true);
    clearLog();
    showProgress(true);
    
    log('Reading backup file...', 'info');
    const backupText = await file.text();
    const backupData = JSON.parse(backupText);
    
    // Validate backup
    if (!backupData.metadata || !backupData.metadata.shopId) {
      throw new Error('Invalid backup file format: Missing metadata');
    }
    
    const { targetShopID, restoreMode, selectedTables } = restoreOptions;
    
    log(`Restoring to Shop ID: ${targetShopID}`, 'info');
    log(`Mode: ${restoreMode}`, 'info');
    log(`Tables: ${selectedTables.join(', ')}`, 'info');
    
    // Backup original shop ID
    const originalShopID = backupData.metadata.shopId;
    
    // Calculate total records to restore
    let totalRecords = 0;
    const tablesToRestore = [];
    
    for (const tableName of selectedTables) {
      if (backupData[tableName] && Array.isArray(backupData[tableName])) {
        tablesToRestore.push({ 
          tableName, 
          data: backupData[tableName] 
        });
        totalRecords += backupData[tableName].length;
      } else {
        log(`Warning: Table "${tableName}" not found in backup`, 'warning');
      }
    }
    
    if (tablesToRestore.length === 0) {
      throw new Error('No valid tables found in backup for selected tables');
    }
    
    log(`Found ${tablesToRestore.length} tables with ${totalRecords} total records to restore`, 'info');
    
    // Handle replace mode - delete existing data first
    if (restoreMode === 'replace') {
      log(`Replace mode: Deleting existing data from target shop...`, 'warning');
      let deletedCount = 0;
      
      for (const { tableName } of tablesToRestore) {
        try {
          const count = await deleteTableData(TABLES[tableName], targetShopID);
          deletedCount += count;
          log(`Deleted ${count} records from ${tableName}`, 'info');
        } catch (error) {
          log(`Error deleting from ${tableName}: ${error.message}`, 'error');
        }
      }
      
      log(`Deleted ${deletedCount} existing records`, 'info');
    }
    
    // Start restore process
    let restoredCount = 0;
    let errors = 0;
    let skippedCount = 0;
    
    for (const { tableName, data } of tablesToRestore) {
      log(`Restoring ${tableName} (${data.length} records)...`, 'info');
      
      for (const record of data) {
        try {
          // Prepare record for insertion
          const recordToInsert = { ...record };
          delete recordToInsert.id; // Remove ID to avoid conflicts
          
          // Update ShopID to target shop
          if (recordToInsert.ShopID !== undefined) {
            // Check if we're restoring to a different shop
            if (originalShopID !== targetShopID) {
              recordToInsert.ShopID = targetShopID;
              log(`Changing ShopID from ${originalShopID} to ${targetShopID}`, 'info');
            }
          }
          
          // For update mode, check if record exists
          if (restoreMode === 'update') {
            // You would need to implement record lookup logic here
            // For now, we'll just insert as new
          }
          
          await fetch(`${BASE_URL}/${TABLES[tableName]}/?user_field_names=true`, {
            method: 'POST',
            headers,
            body: JSON.stringify(recordToInsert)
          });
          
          restoredCount++;
          setProgress(restoredCount, totalRecords);
          
        } catch (error) {
          errors++;
          log(`Failed to restore record in ${tableName}: ${error.message}`, 'error');
        }
      }
    }
    
    const successCount = restoredCount - errors;
    
    if (errors > 0) {
      log(`‚ö†Ô∏è Restore completed with ${errors} errors.`, 'warning');
    }
    
    log(`‚úÖ Restore completed!`, 'success');
    log(`Summary:`, 'info');
    log(`  Successfully restored: ${successCount} records`, 'success');
    log(`  Failed: ${errors} records`, errors > 0 ? 'error' : 'info');
    log(`  Target Shop ID: ${targetShopID}`, 'info');
    
    if (originalShopID !== targetShopID) {
      log(`Note: Data was transferred from Shop ${originalShopID} to Shop ${targetShopID}`, 'info');
    }
    
    // Refresh stats if restoring to current shop
    const currentShopID = getShopID();
    if (targetShopID === currentShopID) {
      setTimeout(async () => {
        showProgress(false);
        await loadShopStats();
      }, 1000);
    } else {
      showProgress(false);
    }
    
    alert(`Restore completed!
Target Shop: ${targetShopID}
Successfully restored: ${successCount} records
Failed: ${errors} records
${originalShopID !== targetShopID ? `\nNote: Data was transferred from Shop ${originalShopID}` : ''}`);
    
  } catch (error) {
    log(`Restore failed: ${error.message}`, 'error');
    alert(`Restore failed: ${error.message}`);
  } finally {
    setAllButtonsState(false);
    e.target.value = '';
    restoreOptions = {
      targetShopID: '',
      restoreMode: 'merge',
      selectedTables: []
    };
  }
};

// ================= DELETE FUNCTION =================
async function deleteShop() {
  if (isOperationInProgress) {
    alert('Please wait for the current operation to complete.');
    return;
  }
  
  const currentShopID = getShopID();
  const shopName = `Shop ${currentShopID}`;
  
  // Triple confirmation for safety
  if (!confirm(`‚ö†Ô∏è DANGER: This will delete ALL data for "${shopName}". Continue?`)) {
    return;
  }
  
  const confirmation = prompt(`Type "DELETE ${shopName}" to confirm permanent deletion:`);
  if (confirmation !== `DELETE ${shopName}`) {
    alert('Deletion cancelled. Confirmation text did not match.');
    return;
  }
  
  if (!confirm(`üö® FINAL WARNING: This action is PERMANENT and CANNOT BE UNDONE!\n\nALL data for "${shopName}" will be lost forever.\n\nAre you absolutely sure?`)) {
    return;
  }
  
  try {
    setAllButtonsState(true);
    clearLog();
    showProgress(true);
    
    log('Starting shop deletion process...', 'warning');
    
    // Get counts first
    let totalRecords = 0;
    const tableCounts = {};
    
    for (const [tableName, tableId] of Object.entries(TABLES)) {
      if (tableName === 'shops') continue;
      
      try {
        const data = await fetchWithPagination(tableId, { shopID: currentShopID });
        tableCounts[tableName] = data.length;
        totalRecords += data.length;
      } catch (error) {
        tableCounts[tableName] = 0;
      }
    }
    
    log(`Found ${totalRecords} records to delete across ${Object.keys(tableCounts).length} tables`, 'warning');
    
    // Delete records from each table
    let deletedCount = 0;
    let errors = 0;
    
    for (const [tableName, tableId] of Object.entries(TABLES)) {
      if (tableName === 'shops') continue;
      
      const count = tableCounts[tableName];
      if (count === 0) continue;
      
      log(`Deleting ${tableName} (${count} records)...`, 'warning');
      
      try {
        const data = await fetchWithPagination(tableId, { shopID: currentShopID });
        
        for (const record of data) {
          try {
            await fetch(`${BASE_URL}/${tableId}/${record.id}/`, {
              method: 'DELETE',
              headers
            });
            deletedCount++;
            setProgress(deletedCount, totalRecords);
          } catch (error) {
            errors++;
            log(`Failed to delete record in ${tableName}: ${error.message}`, 'error');
          }
        }
      } catch (error) {
        log(`Error accessing ${tableName}: ${error.message}`, 'error');
      }
    }
    
    if (errors > 0) {
      log(`‚ö†Ô∏è Deletion completed with ${errors} errors. ${deletedCount} records deleted.`, 'warning');
      alert(`Deletion completed with ${errors} errors.\n${deletedCount} records were deleted.`);
    } else {
      log(`‚úÖ Shop deletion completed! ${deletedCount} records deleted permanently.`, 'success');
      alert(`Shop "${shopName}" has been deleted permanently.\n\n${deletedCount} records were removed.\n\nYou will now be logged out.`);
      
      // Clear localStorage and redirect
      localStorage.clear();
      setTimeout(() => {
        window.location.href = '/login.html';
      }, 2000);
    }
    
  } catch (error) {
    log(`Deletion failed: ${error.message}`, 'error');
    alert(`Deletion failed: ${error.message}`);
  } finally {
    setAllButtonsState(false);
    showProgress(false);
  }
}

// ================= INITIALIZATION =================
async function initialize() {
  try {
    log('Initializing shop management system...', 'info');
    await loadShopInfo();
    log('‚úÖ System ready. You can now perform backup, restore, or delete operations.', 'success');
  } catch (error) {
    log(`‚ùå Initialization failed: ${error.message}`, 'error');
    document.getElementById('page').innerHTML = `
      <div style="text-align: center; padding: 40px;">
        <h2 style="color: #f5576c;">‚ùå Initialization Error</h2>
        <p>${error.message}</p>
        <p>Please ensure you are logged in and have proper permissions.</p>
        <button onclick="location.reload()" class="primary" style="margin-top: 20px;">
          üîÑ Retry
        </button>
      </div>
    `;
  }
}

// Start the application when page loads
window.addEventListener('DOMContentLoaded', initialize);

// Add keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey || e.metaKey) {
    switch(e.key.toLowerCase()) {
      case 'b':
        e.preventDefault();
        if (!isOperationInProgress) downloadAllData();
        break;
      case 'r':
        e.preventDefault();
        if (!isOperationInProgress) showRestoreModal();
        break;
      case 'd':
        if (e.shiftKey) {
          e.preventDefault();
          if (!isOperationInProgress) deleteShop();
        }
        break;
    }
  }
});
</script>
</body>
</html>